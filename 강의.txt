프레임워크 vs 라이브러리
프레임: 어떠한 앱을 만들기 위해 필요한 대부분의 것을 가지고있음
라이브: 어떠한 특정 기능을 모듈화해놓음
프레임워크 안에 많은 라이브러리가있음

react : 사용자 인터페이스를 위한 자바스크립트 라이브러리

화면바꾸는 라우팅 - react-router-dom 모듈 사용
상태관리를 위해 - redux,mobx사용
빌드를 위해 webpack, npm
테스팅을 위해 eslint, mocha를 이용
그래서 라이브러리다


spa 란?
웹사이트의 전체페이지를 하나의 페이지에 담아 동적으로 화면을 바꿔가며 표현
html5 의 history api 이용 페이지를 바꿈

가상돔은 실제 DOM의 가벼운 복사본으로, 변경 사항을 메모리에서 먼저 계산해 실제 DOM 조작을 최소화해 성능을 높입니다.
실제 DOM은 변경 시마다 브라우저가 렌더링을 반복해 느려질 수 있지만, 가상돔은 변경점을 비교(diff)해 꼭 필요한 부분만 실제 DOM에 반영하므로 빠르고 효율적인 UI 업데이트가 가능합니다.

1. Props는 Properties의 줄임말.

2. Props는 상속하는 부모 컴포넌트로부터
자녀 컴포넌트에 데이터등을 전달하는 방법

3. Props는 읽기 전용(immutable)으로
자녀 컴포넌트 입장에서는 변하지 않는다.
(변하게 하고자 하면 부모 컴포넌트에서
state를 변경시켜줘야한다.)


React State란 무엇인가요?

컴포넌트의 렌더링 결과물에 영향을 주는 데이터를 갖고 있는 객체입니다. (State가 변경되면 컴포
넌트는 리랜더링(Re-rendering)됩니다. 또한 State는 컴포넌트 안에서 관리됩니다.

Constructor

constructor(생성자)를 사용하면 인스턴스화된 객체에서 다른 메서드를 호출하기
전에 수행해야 하는 사용자 지정 초기화를 제공할 수 있습니다.

클래스를 new 를 붙여서 (new User("John") ) 인스턴스 객채로 생성하면 넘겨받
은 인수와 함께 constructor가 먼저 실행됩니다.
이 때 넘겨받은 인수인 John이 this.name 에 할당 됩다.


자바스크립트에서 super
- super 키워드는 자식 클래스 내에서 부모 클래스의 생성자를 호출할 때 사
용됩니다.

- super 키워드는 자식 클래스 내에서 부모 클래스의 메소드를 호출할 때 사
용됩니다.

super 이후에 this 키워드

- 생성자에서는 super 키워드 하나만 사용되거나 this 키워드가 사용되기 전에 호출되어야 합니다.

문법
super([arguments]); // 부모 생성자 호출
super.functionOnParent([arguments]);

전개 연산자는 무엇인가요?

전개 연산자는 ECMAScript6(2015)에서 새롭게 추가되었으며, 특정 객체 또는 배열의 값을 다른
객체, 배열로 복제하거나 옮길 때 사용합니다. 연산자의 모양은 ... 이렇게 생겼습니다.

배열 조합
const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = [7, 8, 9];
const arrwrap = arr1.concat(arr2, arr3);

console.log(arrWrap); // [1, 2, 3, 4, 5, 6, 7, 8, 9]



const arr1 = [1, 2, 3];
const arr2 = [4, 5, 6];
const arr3 = [7, 8, 9];
const arrWrap = [ ... arr1, ... arr2, ... arr3];
console.log(arrWrap); // [1, 2, 3, 4, 5, 6, 7, 8, 9]


const arr1 = [1, 2, 3];
const arr2 = [4, 5];
Array.prototype.push.apply(arr1, arr2);
console.log(arr1); // [1, 2, 3, 4, 5]


const arr1 = [1, 2, 3];
const arr2 = [4, 5];
arr1.push( ... arr2);
console.log(arr1); // [1, 2, 3, 4, 5]


useEffect

컴포넌트가 렌더링 될 때 특정 작업을 실행할 수 있도록 하는 Hook입니다.
여기서는 App 컴포넌트가 한번 렌더링 된 후에 jsonplaceholder라는 곳의 서버에 비동기 요
청을 보내서 posts 데이터를 가져오기 위해서 사용됐습니다.
현재는 profiler를 살펴보는 부분에 집중하기 위해서 나중에 useEffect에 대해서 더 자세히
알아보겠습니다.


fetch() 메소드

- 원격 API 에 요청을 보내기 위해 사용할 수 있는 메소드 입니다.

- 전역 fetch() 메서드는 네트위크에서 리소스를 가져오는 프로세스를 시작하여 Response응
답을 사용할 수 있게 되면 이행된 Promise약속을 Return만환합니다.

key
React가 리스트 형태의 컴포넌트를 렌더링할 때, 각 요소를 고유하게 식별하기 위해 사용하는 속성
리스트를 렌더링할 때, React는 DOM을 완전히 다시 만드는 대신 변화된 부분만 효율적으로 갱신(diffing)합니다.
그런데 key가 없으면 React는 각 항목을 구분할 방법이 없어요.
{items.map(item => <li>{item.name}</li>)}
이렇게 하면 React 입장에서 각 <li>가 서로 어떤 관계인지 알 수 없습니다.

그래서 key를 사용해 React가 각 요소를 고유하게 추적할 수 있게 합니다 👇
{items.map(item => <li key={item.id}>{item.name}</li>)}

jsonplaceholder
- JSONPlaceholder는 가짜 데이터가 필요할 때마다 사용할 수 있는 무료 온라인 REST
API입니다.
- posts, users, photos 등 여러 가지 가짜 데이터를 가져올 수 있습니다.


React.memo() 란?

React는 먼저 컴포넌트를 렌더링(rendering) 한 뒤, 이전에 렌더링 된 결과와 비교하여 DOM 업데이트를
결정합니다. 만약 렌더링 결과가 이전과 다르다면, React는 DOM을 업데이트합니다.

이 과정에서 만약 컴포넌트가 React.memo()로 둘러 쌓여 있다면, React는 컴포넌트를 렌더링하고 결과
를 메모이징(Memoizing)한다. 그리고 다음 렌더링이 일어날 때 렌더링하는 컴포넌트의 props가 같다면,
React는 메모이징(Memoizing)된 내용을 재사용 합니다.

메모이제이션 (Memoization) 이란?
Memoization은 주어진 입력값에 대한 결과를 저장함으로써 같은 입력값에 대해 함수가 한 번만 실행되는 것을
보장한다

처음 렌더링 할 때 결과를 메모이징 합니다. 그리고 다음 렌더링 시 props가 같기 때문에
메모이징 된 내용을 재 사용합니다.

React Memo  사용을 지양해야하는 상황
렌더링 될 때 props가 다른 경우가 대부분인 컴포넌트를 생각해 년면, 메모이제이션 기법의 이점을 얻기 힘듭
니다.
props가 자주 변하는 컴포넌트를 React.memo()로 래핑 하시라도, React는 두 가지 작업을 리 렌더링 할
때마다 수행합니다.
1. 이전 props와 다음 props의 동등 비교를 위해 비교 함수를 수행합니다.
2. 비교 함수는 거의 항상 false를 반환할 것이기 때문에, React는 이전 렌더링 내용과 다음 렌더링 내용을
비교합니다.
비교 함수의 결과는 대부분 false를 반환하기에 props 비교는 불필요하게 됩나다.

React.memo()는 리렌더링을 막기 위한 도구보다 성능 개선의 도구
React에서는 성능 개선을 위한 하나의 도구로 메모이제이션을 사용합니다.
대부분의 상황에서 React는 메모이징 된 컴포넌트 리 렌더링을 피할 수 있지만, 렌더링을 막기 위해 메모
이제이션에 너무 의존하면 안됩니다(버그 유발 가능성이 있습니다).

결론

리액트에서 렌더링 성능 최적화 위해선 React 컴포넌트를 분리하며, React.memo를 사용하면 됩니다. 또
한 React.memo 사용은 항상 좋은 것은 아니기에 profiler를 이용해서 성능상 이점이 있는지 확인 후 사용
하면 좋습니다.


얕은 비교 Shallow Compare란 ?
숫자, 문자열 등 원시 자료형은 값을 비교합니다.
베열, 객체 등 참조 자료형은 값 혹은 속성을 비교하지 않고, 참조되는 위치를 비교합니다.

깊은 비교 란 ?

얕은 비교와 달리 깊은 비교는 객체의 경우에도 값으로 비교합니다. 깊은 비교 방법은 아래와 같습니다.
1. Object depth가 깊지 않은 경우 : JSON.stringify() 사용
2. Object depth가 깊은 경우 : lodash+라이브러리의 isEqual() 사용

"얕은 비교"를 언제 사용하나요?
1. React.memo()에서 props를 비교할 때
2. 리액트 컴포넌트가 리 렌더링을 하기 전
- state 변경이 있을 때
- 부모 컴포넌트가 렌더링 될 때

참조) 리액트가 리렌더링 되는 경우
- state 변경이 있을 때
- 부모 컴포넌트가 렌더링 될 때
- 새로운 props이 들어올 때
- shouldComponentUpdate에서 true가 반환될 때
- forceUpdate가 실행될 때


useCallback 
메모이제이션된 함수를 반환하는 함수입니다.

useCallback 적용은 useCallback 안에 콜백함수와 의존성 배열을 순서대로 넣어주시면 됩니다.
const testFunction = useCallback ( () => { }, []);

함수 내에서 참조하는 state, props가 있다면 의존 '배일에 추가 새주시면 됩니다.

useCallback으로 인해서 의존성 배열에 추가해준 state 혹은 props가 변하지 않는다면 함수는 새로
생성되지 않습니다.

새로 생성되지 않기에 메모리에 새로 할당되지 않고 동일 참조 값을 사용하게 됩니다.

의존성 배열에 아무것도 없다면 컴포넌트가 최초 렌더링 시에만 함수가 생성되며 그 이후에는 동일한 참
조 값을 사용하는 함수가 됩니다.


Memoization 이란 ?

메모이제이션은 비용이 많이 드는 함수 호출의 결과를 저장하고 동일한 입력이 다시 발생할 때 캐시된 결과
를 반환하여 컴퓨터 프로그램의 속도를 높이는 데 주로 사용되는 최적화 기술입니다.

function Component({ a, b }) {
const result = compute(a, b)
return <div>{result}</div>
}

Component 내의 compute 함수가 만약 복잡한 연산을 수행하면 결과 값을 리턴하는데 오랜 시간이 걸리
게 됩니다. 이럴 시에 컴포넌트가 계속 리 렌더링 된다면 연산을 계속 수행하는데 오랜 시간이 걸려서 성능
에 안 좋은 영향을 미치게 되며, UI 지연 현상도 일어나게 될 것입니다.

이러한 현상을 해결해주기 위해서 사용하는 것이 useMemo 입니다.
compute 함수에 넘겨주는 a, b의 값이 이전과 동일하다면 컴포넌트가 리 렌더링 되더라도 연산을 다시 하
지 않고 이전 렌더링 때 저장해두었던 값을 재활용하게 됩니다.

useMemo 적용하기
useMemo로 감싸준 후에 첫번째 인수에 의존싱 배열에 compute 함수에서 사용하는 값을 넣어줍니다.

function Component({ a, b }) {
const result = useMemo(() => compute(a, b), [a, b])
return <div>{result}</div>
}
